# JS의 메모리 관리

JS같은 고수준 언어에서는 가비지컬렉션으로 사용하지 않는 메모리를 해제시켜 메모리가 관리된다.

### 값 사용

할당된 메모리를 읽고 쓴다. 

### 메모리 해제

“할당된 메모리가 더 이상 필요없을 때" 해제하게 된다.

이 시점을 알아내기 어렵기 때문에 문제가 발생한다.

C와 같은 저수준 언어에서는 메모리가 필요없어질 때를 개발자가 직접 결정하고 해제하는 방식을 사용한다.

JS와 같은 고수준 언어에서는 `가비지 컬렉션(GC)` 라는 자동 메모리 관리 방법을 사용한다.

가비지 콜렉터는 메모리 할당을 추적하고 할당된 메모리 블록이 더 이상 필요하지 않게 됐는지를 판단하여 회수한다. 이러한 메모리 관리 프로세스는 비결정적 문제이기 때문에 궁극적인 방법은 아니다.

### 가비지 컬렉터의 알고리즘과 그 한계

가비지 컬렉션 알고리즘의 핵심 개념은 `참조` 이다. A라는 메모리를 통해 B라는 메모리에 접근할 수 있다면 “B는 A에 참조된다" 라고 한다. 예를 들어 모든 JS 오브젝트는 prototype을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.

1. 참조-세기(Reference-counting) 가비지 콜렉션

 참조-카운트 알고리즘은 가장 소박한 알고리즘이다. 이 알고리즘에서는 “더 이상 필요없는 오브젝트"를 “어떤 다른 오브젝트도 참조하지 않는 오브젝트" 라고 정의한다. 이 오브젝트를 “가비지”라 부르며, 이를 참조하는 다른 오브젝트가 하나도 없는 경우, 수집이 가능하다.

**한계: 순환 참조**

 함수 내에서 두 객체가 서로 참조하는 속성으로 순환 구조를 생성하는 경우가 있다. 함수 호출이 완료되면 이 두 객체는 스코프를 벗어나게 되며, 그 시점에서 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 한다. 그러나 두 객체가 서로를 참조하고 있으므로, 참조-세기 알고리즘은 둘 다 가비지 컬렉션의 대상으로 인식하지 않는다.

→ 순환 참조는 메모리 누수의 흔한 원인이다.

1. 표시-쓸기(Mark-and-sweep) 알고리즘

 이 알고리즘은 “더 이상 필요없는 오브젝트" 를 “닿을 수 없는 오브젝트"로 정의한다. 이 알고리즘은 `roots` 라는 오브젝트의 집합을 가지고 있다. (JS에서는 전역 변수들을 의미한다.) 주기적으로 가비지 콜렉터는 `roots` 로 부터 시작하여 roots가 참조하는 오브젝트, 그 오브젝트가 참조하는 오브젝트... 까지를 `닿을 수 있는 오브젝트` 라고 표시한다. 그리고 `닿을 수 있는 오브젝트` 가 아닌 닿을 수 없는 오브젝트에 대해 가비지 콜렉션을 수행한다.

 이 알고리즘은 참조-세기 알고리즘보다 효율적이다. `참조되지 않는 오브젝트` 는 모두 `닿을 수 없는 오브젝트` 이지만 역은 성립하지 않기 때문에 순환참조 문제를 해결할 수 있다.

**한계: 수동 메모리 해제**

 어떤 메모리를 언제 해제할지에 대해 수동으로 결정하는 것이 편리할 때가 있다. JS에선 그렇게 하려면, 객체 메모리에 도달할 수 없도록 명시하는 기능이 필요하다.

### 최적화 기법

1. generational collection(세대별 수집)

→ 객체를 ‘새로운 객체'와 ‘오래된 객체'로 나눈다.

 객체의 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 ‘새로운 객체'로 구분하여 공격적으로 메모리에서 제거한다. 일정 시간 이상 동안 살아남은 객체는 ‘오래된 객체'로 분류하고, 가비지 컬렉터가 덜 감시한다.

1. incremental collection(점진적 수집)

→ 가비지 컬렉션을 여러 부분으로 분리한 다음 별도로 수행한다.

→ 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있다.

1. idle-time collection(유휴 시간 수집)

→ CPU가 유후 상태일 때에만 가비지 컬렉션을 실행한다.